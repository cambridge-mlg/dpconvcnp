from abc import abstractmethod, ABC
from typing import List, Tuple, Callable, Optional

import tensorflow as tf
import tensorflow_probability as tfp
import numpy as np

from dpconvcnp.data.data import SyntheticGenerator
from dpconvcnp.random import Seed, randn, randu
from dpconvcnp.utils import i32, f32, f64, to_tensor, cast

tfd = tfp.distributions

def _sawtooth(
        d: tf.Tensor,
        x: tf.Tensor,
        phi: tf.Tensor,
        freq: tf.Tensor,
    ) -> tf.Tensor:
    """
    Computes output of the sawtooth function given a normalised direction
    vector `d`, a tensor of inputs `x`, a phase parameter `phi` and a
    frequency `freq`.

    Arguments:
        d: Tensor of shape (batch_size, dim) containing normalised direction
            vectors.
        x: Tensor of shape (batch_size, num_ctx + num_trg, dim) containing
            the context and target inputs.
        phi: Tensor of shape (batch_size,) containing phase parameters.
        freq: Tensor of shape (batch_size,) containing frequencies.

    Returns:
        y: Tensor of shape (batch_size, num_ctx + num_trg, 1) containing
            the context and target outputs.
    """
    freq = freq[:, None, None]
    phi = (1 / freq) * phi[:, None, None]
    y = tf.einsum("bd, bnd -> bn", d, x)[:, :, None] + phi
    y = 2 * (freq * (y % (1 / freq)) - 0.5)
    return y

def _tophat(
        d: tf.Tensor,
        x: tf.Tensor,
        phi: tf.Tensor,
        freq: tf.Tensor,
    ) -> tf.Tensor:
    """
    Computes output of the tophat function given a normalised direction
    vector `d`, a tensor of inputs `x`, a phase parameter `phi` and a
    frequency `freq`.

    Arguments:
        d: Tensor of shape (batch_size, dim) containing normalised direction
            vectors.
        x: Tensor of shape (batch_size, num_ctx + num_trg, dim) containing
            the context and target inputs.
        phi: Tensor of shape (batch_size,) containing phase parameters.
        freq: Tensor of shape (batch_size,) containing frequencies.

    Returns:
        y: Tensor of shape (batch_size, num_ctx + num_trg, 1) containing
            the context and target outputs.
    """
    freq = freq[:, None, None]
    phi = 0.5 / freq * phi[:, None, None]
    y = tf.einsum("bd, bnd -> bn", d, x)[:, :, None] + phi
    y = 2. * ((y // (0.5 / freq)) % 2) - 1.
    return y

class WaveformGenerator(SyntheticGenerator, ABC):
    def __init__(
        self,
        *,
        waveform_func: Callable,
        min_frequency: float,
        max_frequency: float,
        noise_std: float,
        dim: int,
        **kwargs,
    ):
        super().__init__(**kwargs)

        assert waveform_func in [_sawtooth, _tophat]

        self.min_frequency = min_frequency
        self.max_frequency = max_frequency
        self.noise_std = noise_std
        self.waveform_func = waveform_func
        self.dim = dim

    def sample_outputs(
        self, seed: Seed, x: tf.Tensor,
    ) -> Tuple[Seed, tf.Tensor, Callable]:
        """Sample context and target outputs, given the inputs `x`.

        Follows the implementation in the neuralprocesses repo:
            wesselb/neuralprocesses/data/sawtooth.py

        Arguments:
            seed: Random seed.
            x: Tensor of shape (batch_size, num_ctx + num_trg, dim) containing
                the context and target inputs.

        Returns:
            seed: Random seed generated by splitting.
            y: Tensor of shape (batch_size, num_ctx + num_trg, 1) containing
                the context and target outputs.
        """

        B, N, D = x.shape

        # Draw normalised direction vector
        seed, d = randn(
            shape=(B, D),
            seed=seed,
            mean=tf.zeros((B, D), dtype=x.dtype),
            stddev=tf.ones((B, D), dtype=x.dtype),
        )
        d = d / tf.reduce_sum(
            d**2. + 1e-6,
            axis=-1,
            keepdims=True,
        )**0.5

        # Draw frequency
        seed, freq = randu(
            shape=(B,),
            seed=seed,
            minval=self.min_frequency*tf.ones((B,), dtype=x.dtype),
            maxval=self.max_frequency*tf.ones((B,), dtype=x.dtype),
        )

        # Draw phase parameter phi
        seed, phi = randu(
            shape=(B,),
            seed=seed,
            minval=tf.zeros((B,), dtype=x.dtype),
            maxval=tf.ones((B,), dtype=x.dtype),
        )

        # Sample observation noise
        seed, noise = randn(
            shape=(B, N, 1),
            seed=seed,
            mean=tf.zeros((B, N, 1), dtype=x.dtype),
            stddev=self.noise_std*tf.ones((B, N, 1), dtype=x.dtype),
        )

        # Use waveform function to generate outputs and add noise
        y = self.waveform_func(d, x, phi, freq) + noise

        return seed, y, None
        
class SawtoothGenerator(WaveformGenerator):
    def __init__(self, **kwargs):
        super().__init__(waveform_func=_sawtooth, **kwargs)

class TophatGenerator(WaveformGenerator):
    def __init__(self, **kwargs):
        super().__init__(waveform_func=_tophat, **kwargs)
