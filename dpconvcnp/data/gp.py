from abc import abstractmethod, ABC
from typing import Dict, Tuple

import tensorflow as tf
import gpflow

from dpconvcnp.data.data import SyntheticGenerator
from dpconvcnp.random import randu, zero_mean_mvn
from dpconvcnp.random import Seed
from dpconvcnp.utils import f32, f64, to_tensor, cast


KERNEL_TYPES = [
    "eq",
    "matern12",
    "matern32",
    "matern52",
    "noisy_mixture",
    "weakly_periodic",
]


class GPGenerator(SyntheticGenerator, ABC):
    
    def __init__(
        self,
        *,
        dim: int,
        noise_std: float,
        **kwargs,
    ):
        super().__init__(**kwargs)

        self.dim = dim
        self.noise_std = noise_std

    def sample_outputs(self, seed: Seed, x: tf.Tensor) -> Tuple[Seed, tf.Tensor]:
        """Sample context and target outputs, given the inputs `x`.
        
        Arguments:
            seed: Random seed.
            x: Tensor of shape (batch_size, num_ctx + num_trg, dim) containing
                the context and target inputs.

        Returns:
            seed: Random seed generated by splitting.
            y: Tensor of shape (batch_size, num_ctx + num_trg, 1) containing
                the context and target outputs.
        """

        # Set up GP kernel
        seed, kernel = self.set_up_kernel(seed=seed)

        # Set up covariance at input locations
        kxx = kernel(cast(x, f64)) + \
            gpflow.kernels.White(self.noise_std**2.)(cast(x, f64))

        # Sample from GP with zero mean and covariance kxx
        seed, y = zero_mean_mvn(seed=seed, cov=kxx)
        y = tf.expand_dims(y, axis=-1)

        return seed, cast(y, f32)

    @abstractmethod
    def set_up_kernel(self, seed: Seed) -> Tuple[Seed, gpflow.kernels.Kernel]:
        """Set up GP kernel.
        
        Arguments:
            seed: Random seed.

        Returns:
            seed: Random seed generated by splitting.
            kernel: GP kernel.
        """
        pass


class RandomScaleGPGenerator(GPGenerator):

    noisy_mixture_long_lengthscale: float = 1.
    weakly_periodic_period: float = 0.25

    def __init__(
        self,
        *,
        kernel_type: str,
        min_log10_lengthscale: float,
        max_log10_lengthscale: float,
        **kwargs,
    ):
        super().__init__(**kwargs)

        self.kernel_type = kernel_type
        self.min_log10_lengthscale = to_tensor(min_log10_lengthscale, f64)
        self.max_log10_lengthscale = to_tensor(max_log10_lengthscale, f64)

        assert self.kernel_type in KERNEL_TYPES


    def set_up_kernel(self, seed: Seed) -> Tuple[Seed, gpflow.kernels.Kernel]:

        # Sample lengthscale
        seed, log10_lengthscale = randu(
            shape=(),
            seed=seed,
            minval=self.min_log10_lengthscale,
            maxval=self.max_log10_lengthscale,
        )
        lengthscale = tf.pow(10.0, log10_lengthscale)
        
        if self.kernel_type == "eq":
            kernel = gpflow.kernels.SquaredExponential(lengthscales=lengthscale)
        
        elif self.kernel_type == "matern12":
            kernel = gpflow.kernels.Matern12(lengthscales=lengthscale)

        elif self.kernel_type == "matern32":
            kernel = gpflow.kernels.Matern32(lengthscales=lengthscale)

        elif self.kernel_type == "matern52":
            kernel = gpflow.kernels.Matern52(lengthscales=lengthscale)

        elif self.kernel_type == "noisy_mixture":
            kernel = gpflow.kernels.SquaredExponential(
                lengthscales=lengthscale,
            ) + gpflow.kernels.SquaredExponential(
                lengthscales=self.noisy_mixture_long_lengthscale,
            )

        elif self.kernel_type == "weakly_periodic":
            kernel = gpflow.kernels.SquaredExponential(
                lengthscales=lengthscale,
            ) * gpflow.kernels.Periodic(
                period=self.weakly_periodic_period,
            )

        return seed, kernel
