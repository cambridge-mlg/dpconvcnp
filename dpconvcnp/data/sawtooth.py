from abc import abstractmethod, ABC
from typing import List, Tuple, Callable, Optional

import tensorflow as tf
import tensorflow_probability as tfp
import numpy as np

from dpconvcnp.data.data import SyntheticGenerator
from dpconvcnp.random import Seed, randn, randu
from dpconvcnp.utils import i32, f32, f64, to_tensor, cast

tfd = tfp.distributions

def _sawtooth(
        d: tf.Tensor,
        x: tf.Tensor,
        phi: tf.Tensor,
        freq: tf.Tensor,
    ):
    freq = freq[:, None, None]
    y = tf.einsum("bd, bnd -> bn", d, x)[:, :, None] + phi[:, None, None]
    y = 2 * (freq * (y % (1 / freq)) - 0.5)
    return y

class SawtoothGenerator(SyntheticGenerator, ABC):
    def __init__(
        self,
        *,
        min_frequency: float,
        max_frequency: float,
        noise_std: float,
        dim: int,
        **kwargs,
    ):
        super().__init__(**kwargs)

        self.min_frequency = min_frequency
        self.max_frequency = max_frequency
        self.noise_std = noise_std
        self.dim = dim

    def sample_outputs(
        self, seed: Seed, x: tf.Tensor,
    ) -> Tuple[Seed, tf.Tensor, Callable]:
        """Sample context and target outputs, given the inputs `x`.

        Follows the implementation in the neuralprocesses repo:
            wesselb/neuralprocesses/data/sawtooth.py

        Arguments:
            seed: Random seed.
            x: Tensor of shape (batch_size, num_ctx + num_trg, dim) containing
                the context and target inputs.

        Returns:
            seed: Random seed generated by splitting.
            y: Tensor of shape (batch_size, num_ctx + num_trg, 1) containing
                the context and target outputs.
        """

        B, N, D = x.shape

        # Draw normalised direction vector
        seed, d = randn(
            shape=(B, D),
            seed=seed,
            mean=tf.zeros((B, D), dtype=x.dtype),
            stddev=tf.ones((B, D), dtype=x.dtype),
        )
        d = d / tf.reduce_sum(
            d**2. + 1e-6,
            axis=-1,
            keepdims=True,
        )**0.5

        # Draw frequency
        seed, freq = randu(
            shape=(B,),
            seed=seed,
            minval=self.min_frequency*tf.ones((B,), dtype=x.dtype),
            maxval=self.max_frequency*tf.ones((B,), dtype=x.dtype),
        )

        # Draw phase phi
        seed, phi = randu(
            shape=(B,),
            seed=seed,
            minval=tf.zeros((B,), dtype=x.dtype),
            maxval=(1 / freq)*tf.ones((B,), dtype=x.dtype),
        )

        # Sample observation noise
        seed, noise = randn(
            shape=(B, N, 1),
            seed=seed,
            mean=tf.zeros((B, N, 1), dtype=x.dtype),
            stddev=self.noise_std*tf.ones((B, N, 1), dtype=x.dtype),
        )

        def gt_pred(
                x_ctx: tf.Tensor,
                y_ctx: tf.Tensor,
                x_trg: tf.Tensor,
                y_trg: Optional[tf.Tensor] = None,
                **kwargs,
            ):
            mean = _sawtooth(d, x_trg, phi, freq)
            std = self.noise_std*tf.ones_like(mean)
            loglik = tf.reduce_mean(
                tfd.Normal(mean, std).log_prob(y_trg),
                axis=[1, 2],
            ) if y_trg is not None else None
            return mean, std, loglik

        # Sawtooth is 2*((d.T x + phi) % (1 / freq) - 0.5)
        y = _sawtooth(d, x, phi, freq) + noise

        return seed, y, gt_pred
